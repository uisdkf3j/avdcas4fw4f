<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Scene with Custom Interactions</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100vh; touch-action: none; }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        // Get the canvas element
        var canvas = document.getElementById("renderCanvas");

        // Generate the Babylon 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // Create the scene space
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            // Add a camera to the scene
            var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 4, 20, new BABYLON.Vector3(0, 0, 0), scene);

            // Disable default controls
            camera.inputs.clear();

            // Add a light to the scene
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);

            // Variables to store initial touch positions for mobile
            var startX, startY;
            var isDragging = false;
            var lastX, lastY;
            var direction;

            // Function to handle touch start event for mobile
            canvas.addEventListener("touchstart", function (evt) {
                startX = evt.touches[0].clientX;
                startY = evt.touches[0].clientY;
                lastX = startX;
                lastY = startY;
                isDragging = true;
                direction = null; // Reset direction when touch starts
            });

            // Function to handle touch move event for both vertical and horizontal rotation on mobile
            canvas.addEventListener("touchmove", function (evt) {
                if (isDragging && evt.touches.length == 1) {
                    var currentX = evt.touches[0].clientX;
                    var currentY = evt.touches[0].clientY;

                    var deltaX = currentX - lastX;
                    var deltaY = currentY - lastY;

                    // Determine the predominant direction of dragging if not determined yet
                    if (direction === null) {
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            direction = 'horizontal';
                        } else {
                            direction = 'vertical';
                        }
                    }

                    // Perform rotation based on the determined direction
                    if (direction === 'horizontal') {
                        camera.alpha -= deltaX * 0.01; // Adjust sensitivity as needed for alpha axis rotation
                    } else { // direction === 'vertical'
                        camera.beta -= deltaY * 0.01; // Adjust sensitivity as needed for beta axis rotation
                        // Clamp beta to avoid flipping upside down
                        camera.beta = Math.max(0.1, Math.min(Math.PI - 0.1, camera.beta));
                    }

                    // Update last positions
                    lastX = currentX;
                    lastY = currentY;
                }
            });

            // Function to handle touch end event for mobile
            canvas.addEventListener("touchend", function (evt) {
                if (!isDragging) return;

                var endX = evt.changedTouches[0].clientX;
                var endY = evt.changedTouches[0].clientY;

                var deltaX = endX - startX;
                var deltaY = endY - startY;

                // Consider it a tap if the finger didn't move much
                if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
                    var pickResult = scene.pick(endX, endY);
                    if (pickResult.hit) {
                        var target = pickResult.pickedMesh.position;

                        // Animate camera pivot change without altering rotation
                        var alpha = camera.alpha;
                        var beta = camera.beta;
                        var radius = camera.radius;

                        // Adjust radius to fit the selected object in the frame
                        var newRadius = BABYLON.Vector3.Distance(camera.position, target) * 1; // Adjust the multiplier as needed

                        BABYLON.Animation.CreateAndStartAnimation('camTarget', camera, 'target', 60, 6, camera.target, target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                        BABYLON.Animation.CreateAndStartAnimation('camRadius', camera, 'radius', 60, 6, radius, newRadius, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    }
                }

                isDragging = false;
            });

            // Function to handle mouse wheel event for horizontal or vertical rotation on desktop
            var scrolling = false;
            canvas.addEventListener("wheel", function (evt) {
                if (!scrolling) {
                    scrolling = true;

                    var isVerticalScroll = Math.abs(evt.deltaY) > Math.abs(evt.deltaX);
                    if (isVerticalScroll) {
                        camera.beta -= evt.deltaY * -0.005; // Adjust sensitivity as needed for vertical rotation
                    } else {
                        camera.alpha -= evt.deltaX * -0.002; // Adjust sensitivity as needed for horizontal rotation
                    }

                    setTimeout(function () {
                        scrolling = false;
                    }, 0); // Adjust timeout as needed to prevent immediate new scroll event
                }
            });

            // Function to handle click event for changing camera pivot on desktop
            canvas.addEventListener("click", function (evt) {
                var pickResult = scene.pick(evt.clientX, evt.clientY);
                if (pickResult.hit) {
                    var target = pickResult.pickedMesh.position;

                    // Animate camera pivot change without altering rotation
                    var alpha = camera.alpha;
                    var beta = camera.beta;
                    var radius = camera.radius;

                    // Adjust radius to fit the selected object in the frame
                    var newRadius = BABYLON.Vector3.Distance(camera.position, target) * 1; // Adjust the multiplier as needed

                    BABYLON.Animation.CreateAndStartAnimation('camTarget', camera, 'target', 60, 6, camera.target, target, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    BABYLON.Animation.CreateAndStartAnimation('camRadius', camera, 'radius', 60, 6, radius, newRadius, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                }
            });

            // Load GLB models
            BABYLON.SceneLoader.ImportMesh("", "./", "Room_1_Floor.glb", scene, function (meshes) {
                // Adjust position or any other properties of the imported mesh as needed
                meshes.forEach(function (mesh) {
                    mesh.position.y += 1; // Example adjustment
                });
            });

            BABYLON.SceneLoader.ImportMesh("", "./", "Room_2_Floor.glb", scene, function (meshes) {
                // Adjust position or any other properties of the imported mesh as needed
                meshes.forEach(function (mesh) {
                    mesh.position.y += 1; // Example adjustment
                });
            });

            return { scene, camera };
        };

        var { scene, camera } = createScene();

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
            scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            engine.resize();
        });

    </script>
</body>
</html>
